<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç²¾ç¾è¿è¿çœ‹</title>
    <style>
        body {
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
      
        .game-container {
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 20px;
            width: fit-content;
            margin-bottom: 20px;
        }
      
        h1 {
            color: #3a4a6d;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
      
        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 18px;
            color: #3a4a6d;
        }
      
        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 5px;
            background-color: #e0e5ec;
            padding: 10px;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
        }
      
        .tile {
            width: 60px;
            height: 60px;
            background-color: white;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 3px 3px 6px rgba(0, 0, 0, 0.1), 
                        -3px -3px 6px rgba(255, 255, 255, 0.8);
            position: relative;
            overflow: hidden;
        }
      
        .tile:hover {
            transform: translateY(-2px);
            box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.1), 
                        -5px -5px 10px rgba(255, 255, 255, 0.8);
        }
      
        .tile.selected {
            background-color: #ffeb3b;
            transform: scale(0.95);
            box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.1);
        }
      
        .tile.matched {
            visibility: hidden;
            animation: fadeOut 0.5s ease-out;
        }
      
        @keyframes fadeOut {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }
      
        .tile::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 50%);
            border-radius: 8px;
        }
      
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
      
        button {
            background: linear-gradient(135deg, #3a4a6d 0%, #1e2a4a 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
      
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
      
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
      
        .path {
            position: absolute;
            background-color: rgba(76, 175, 80, 0.5);
            z-index: 10;
        }
      
        .emoji-set {
            font-size: 28px;
        }
      
        .timer, .score {
            font-weight: bold;
            background: linear-gradient(135deg, #e0e5ec 0%, #c3cfe2 100%);
            padding: 5px 15px;
            border-radius: 50px;
            box-shadow: inset 2px 2px 5px rgba(0, 0, 0, 0.1), 
                        inset -2px -2px 5px rgba(255, 255, 255, 0.8);
        }
      
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
      
        .game-over.show {
            opacity: 1;
            pointer-events: all;
        }
      
        .game-over-content {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
      
        .game-over.show .game-over-content {
            transform: scale(1);
        }
      
        .game-over h2 {
            color: #3a4a6d;
            margin-top: 0;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>âœ¨ ç²¾ç¾è¿è¿çœ‹ âœ¨</h1>
        <div class="game-info">
            <div class="timer">æ—¶é—´: <span id="time">60</span>ç§’</div>
            <div class="score">åˆ†æ•°: <span id="score">0</span></div>
        </div>
        <div class="game-board" id="gameBoard"></div>
        <div class="controls">
            <button id="newGameBtn">æ–°æ¸¸æˆ</button>
            <button id="hintBtn">æç¤º</button>
            <button id="shuffleBtn">é‡æ’</button>
        </div>
    </div>
  
    <div class="game-over" id="gameOver">
        <div class="game-over-content">
            <h2>æ¸¸æˆç»“æŸ!</h2>
            <p>ä½ çš„æœ€ç»ˆå¾—åˆ†: <span id="finalScore">0</span></p>
            <button id="playAgainBtn">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // æ¸¸æˆé…ç½®
            const config = {
                rows: 8,
                cols: 8,
                timeLimit: 60, // 60ç§’
                emojiSets: [
                    ['ğŸ¶', 'ğŸ±', 'ğŸ­', 'ğŸ¹', 'ğŸ°', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼'],
                    ['ğŸ', 'ğŸ', 'ğŸŠ', 'ğŸ‹', 'ğŸŒ', 'ğŸ‰', 'ğŸ‡', 'ğŸ“'],
                    ['âš½', 'ğŸ€', 'ğŸˆ', 'âš¾', 'ğŸ¾', 'ğŸ', 'ğŸ‰', 'ğŸ±'],
                    ['ğŸš—', 'ğŸš•', 'ğŸš™', 'ğŸšŒ', 'ğŸš', 'ğŸ', 'ğŸš“', 'ğŸš‘'],
                    ['â¤ï¸', 'ğŸ’›', 'ğŸ’š', 'ğŸ’™', 'ğŸ’œ', 'ğŸ–¤', 'ğŸ¤', 'ğŸ¤'],
                    ['ğŸŒ', 'ğŸŒ', 'ğŸŒ›', 'ğŸŒœ', 'ğŸŒš', 'ğŸŒ•', 'ğŸŒ–', 'ğŸŒ—']
                ]
            };
          
            // æ¸¸æˆçŠ¶æ€
            let state = {
                board: [],
                selectedTile: null,
                matchedPairs: 0,
                score: 0,
                timeLeft: config.timeLimit,
                timer: null,
                isGameOver: false,
                currentEmojiSet: []
            };
          
            // DOMå…ƒç´ 
            const gameBoard = document.getElementById('gameBoard');
            const timeDisplay = document.getElementById('time');
            const scoreDisplay = document.getElementById('score');
            const newGameBtn = document.getElementById('newGameBtn');
            const hintBtn = document.getElementById('hintBtn');
            const shuffleBtn = document.getElementById('shuffleBtn');
            const gameOverModal = document.getElementById('gameOver');
            const finalScoreDisplay = document.getElementById('finalScore');
            const playAgainBtn = document.getElementById('playAgainBtn');
          
            // åˆå§‹åŒ–æ¸¸æˆ
            function initGame() {
                // é‡ç½®æ¸¸æˆçŠ¶æ€
                state.board = [];
                state.selectedTile = null;
                state.matchedPairs = 0;
                state.score = 0;
                state.timeLeft = config.timeLimit;
                state.isGameOver = false;
              
                // æ¸…ç©ºæ¸¸æˆæ¿
                gameBoard.innerHTML = '';
              
                // æ›´æ–°æ˜¾ç¤º
                updateDisplay();
              
                // éšæœºé€‰æ‹©ä¸€ç»„emoji
                state.currentEmojiSet = [...config.emojiSets[Math.floor(Math.random() * config.emojiSets.length)]];
              
                // åˆ›å»ºæ¸¸æˆæ¿
                createBoard();
              
                // å¼€å§‹è®¡æ—¶å™¨
                if (state.timer) clearInterval(state.timer);
                state.timer = setInterval(updateTimer, 1000);
              
                // éšè—æ¸¸æˆç»“æŸæ¨¡æ€æ¡†
                gameOverModal.classList.remove('show');
            }
          
            // åˆ›å»ºæ¸¸æˆæ¿
            function createBoard() {
                // åˆ›å»ºé…å¯¹æ•°ç»„ (æ¯ä¸ªemojiå‡ºç°ä¸¤æ¬¡)
                let pairs = [];
                for (let i = 0; i < (config.rows * config.cols) / 2; i++) {
                    const emojiIndex = i % state.currentEmojiSet.length;
                    pairs.push(state.currentEmojiSet[emojiIndex]);
                    pairs.push(state.currentEmojiSet[emojiIndex]);
                }
              
                // éšæœºæ‰“ä¹±æ•°ç»„
                pairs = shuffleArray(pairs);
              
                // åˆ›å»ºæ¸¸æˆæ¿äºŒç»´æ•°ç»„
                for (let row = 0; row < config.rows; row++) {
                    state.board[row] = [];
                    for (let col = 0; col < config.cols; col++) {
                        const index = row * config.cols + col;
                        state.board[row][col] = {
                            emoji: pairs[index],
                            matched: false,
                            element: null
                        };
                      
                        // åˆ›å»ºDOMå…ƒç´ 
                        const tile = document.createElement('div');
                        tile.className = 'tile';
                        tile.innerHTML = `<span class="emoji-set">${pairs[index]}</span>`;
                        tile.dataset.row = row;
                        tile.dataset.col = col;
                      
                        tile.addEventListener('click', () => handleTileClick(row, col));
                      
                        gameBoard.appendChild(tile);
                        state.board[row][col].element = tile;
                    }
                }
            }
          
            // å¤„ç†æ–¹å—ç‚¹å‡»
            function handleTileClick(row, col) {
                if (state.isGameOver) return;
              
                const tile = state.board[row][col];
              
                // å¦‚æœå·²ç»åŒ¹é…æˆ–æ˜¯å·²é€‰ä¸­çš„æ–¹å—ï¼Œåˆ™å¿½ç•¥
                if (tile.matched || (state.selectedTile && state.selectedTile.row === row && state.selectedTile.col === col)) {
                    return;
                }
              
                // å¦‚æœæ²¡æœ‰é€‰ä¸­çš„æ–¹å—ï¼Œé€‰ä¸­å½“å‰æ–¹å—
                if (!state.selectedTile) {
                    state.selectedTile = { row, col };
                    tile.element.classList.add('selected');
                    return;
                }
              
                // å¦‚æœå·²ç»æœ‰ä¸€ä¸ªé€‰ä¸­çš„æ–¹å—ï¼Œæ£€æŸ¥æ˜¯å¦åŒ¹é…
                const selectedTile = state.board[state.selectedTile.row][state.selectedTile.col];
              
                // æ£€æŸ¥æ˜¯å¦ç›¸åŒ
                if (tile.emoji === selectedTile.emoji) {
                    // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿æ¥
                    const path = findPath(
                        { row: state.selectedTile.row, col: state.selectedTile.col },
                        { row, col }
                    );
                  
                    if (path) {
                        // æ˜¾ç¤ºè¿æ¥è·¯å¾„
                        showPath(path);
                      
                        // åŒ¹é…æˆåŠŸ
                        setTimeout(() => {
                            // ç§»é™¤è·¯å¾„
                            clearPath();
                          
                            // æ ‡è®°ä¸ºå·²åŒ¹é…
                            tile.matched = true;
                            selectedTile.matched = true;
                          
                            // æ·»åŠ åŠ¨ç”»ç±»
                            tile.element.classList.add('matched');
                            selectedTile.element.classList.add('matched');
                          
                            // æ›´æ–°çŠ¶æ€
                            state.matchedPairs++;
                            state.score += 10;
                            updateDisplay();
                          
                            // é‡ç½®é€‰ä¸­çš„æ–¹å—
                            state.selectedTile = null;
                          
                            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                            checkGameOver();
                        }, 300);
                    } else {
                        // ä¸èƒ½è¿æ¥ï¼Œå–æ¶ˆé€‰ä¸­
                        selectedTile.element.classList.remove('selected');
                        state.selectedTile = null;
                    }
                } else {
                    // ä¸åŒ¹é…ï¼Œå–æ¶ˆé€‰ä¸­
                    selectedTile.element.classList.remove('selected');
                    state.selectedTile = null;
                }
            }
          
            // æŸ¥æ‰¾è¿æ¥è·¯å¾„ (ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢)
            function findPath(start, end) {
                // å¦‚æœç›´æ¥ç›¸è¿
                if (isDirectlyConnected(start, end)) {
                    return [start, end];
                }
              
                // ä½¿ç”¨BFSæŸ¥æ‰¾è·¯å¾„
                const queue = [{ position: start, path: [start], turns: 0 }];
                const visited = new Set();
                visited.add(`${start.row},${start.col}`);
              
                while (queue.length > 0) {
                    const current = queue.shift();
                  
                    // æ£€æŸ¥å››ä¸ªæ–¹å‘
                    const directions = [
                        { row: -1, col: 0 }, // ä¸Š
                        { row: 1, col: 0 },  // ä¸‹
                        { row: 0, col: -1 }, // å·¦
                        { row: 0, col: 1 }   // å³
                    ];
                  
                    for (const dir of directions) {
                        let newRow = current.position.row + dir.row;
                        let newCol = current.position.col + dir.col;
                      
                        // æ²¿ç€å½“å‰æ–¹å‘ç§»åŠ¨ï¼Œç›´åˆ°é‡åˆ°éšœç¢ç‰©
                        while (true) {
                            // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
                            if (newRow === end.row && newCol === end.col) {
                                return [...current.path, { row: newRow, col: newCol }];
                            }
                          
                            // æ£€æŸ¥æ˜¯å¦è¶…å‡ºè¾¹ç•Œ
                            if (newRow < 0 || newRow >= config.rows || newCol < 0 || newCol >= config.cols) {
                                break;
                            }
                          
                            // æ£€æŸ¥æ˜¯å¦æ˜¯ç©ºç™½æˆ–èµ·ç‚¹/ç»ˆç‚¹
                            const isBlank = state.board[newRow][newCol].matched;
                            const isStartOrEnd = (newRow === start.row && newCol === start.col) || 
                                                (newRow === end.row && newCol === end.col);
                          
                            if (!isBlank && !isStartOrEnd) {
                                break; // é‡åˆ°éšœç¢ç‰©
                            }
                          
                            // è®¡ç®—è½¬å¼¯æ¬¡æ•°
                            let turns = current.turns;
                            if (current.path.length > 1) {
                                const last = current.path[current.path.length - 1];
                                const secondLast = current.path[current.path.length - 2];
                              
                                // æ£€æŸ¥æ–¹å‘æ˜¯å¦æ”¹å˜
                                const prevDirRow = last.row - secondLast.row;
                                const prevDirCol = last.col - secondLast.col;
                              
                                if (prevDirRow !== dir.row || prevDirCol !== dir.col) {
                                    turns++;
                                    if (turns > 2) break; // è¶…è¿‡2æ¬¡è½¬å¼¯
                                }
                            }
                          
                            const key = `${newRow},${newCol}`;
                            if (!visited.has(key)) {
                                visited.add(key);
                                queue.push({
                                    position: { row: newRow, col: newCol },
                                    path: [...current.path, { row: newRow, col: newCol }],
                                    turns: turns
                                });
                            }
                          
                            // ç»§ç»­æ²¿å½“å‰æ–¹å‘ç§»åŠ¨
                            newRow += dir.row;
                            newCol += dir.col;
                        }
                    }
                }
              
                return null; // æ²¡æœ‰æ‰¾åˆ°è·¯å¾„
            }
          
            // æ£€æŸ¥æ˜¯å¦ç›´æ¥ç›¸è¿
            function isDirectlyConnected(a, b) {
                // åŒä¸€è¡Œ
                if (a.row === b.row) {
                    const minCol = Math.min(a.col, b.col);
                    const maxCol = Math.max(a.col, b.col);
                  
                    // æ£€æŸ¥ä¸­é—´æ˜¯å¦æœ‰éšœç¢ç‰©
                    for (let col = minCol + 1; col < maxCol; col++) {
                        if (!state.board[a.row][col].matched) {
                            return false;
                        }
                    }
                    return true;
                }
              
                // åŒä¸€åˆ—
                if (a.col === b.col) {
                    const minRow = Math.min(a.row, b.row);
                    const maxRow = Math.max(a.row, b.row);
                  
                    // æ£€æŸ¥ä¸­é—´æ˜¯å¦æœ‰éšœç¢ç‰©
                    for (let row = minRow + 1; row < maxRow; row++) {
                        if (!state.board[row][a.col].matched) {
                            return false;
                        }
                    }
                    return true;
                }
              
                return false;
            }
          
            // æ˜¾ç¤ºè¿æ¥è·¯å¾„
            function showPath(path) {
                // æ¸…é™¤ä¹‹å‰çš„è·¯å¾„
                clearPath();
                
                // ç»˜åˆ¶æ–°è·¯å¾„
                for (let i = 0; i < path.length - 1; i++) {
                    const start = path[i];
                    const end = path[i + 1];
                    
                    const startTile = state.board[start.row][start.col].element;
                    const endTile = state.board[end.row][end.col].element;
                    
                    const startRect = startTile.getBoundingClientRect();
                    const endRect = endTile.getBoundingClientRect();
                    
                    const pathElement = document.createElement('div');
                    pathElement.className = 'path';
                    
                    // æ°´å¹³è¿æ¥
                    if (start.row === end.row) {
                        const left = Math.min(startRect.left, endRect.left) + startRect.width / 2;
                        const width = Math.abs(startRect.left - endRect.left);
                        
                        pathElement.style.left = `${left}px`;
                        pathElement.style.top = `${startRect.top + startRect.height / 2 - 2}px`;
                        pathElement.style.width = `${width}px`;
                        pathElement.style.height = '4px';
                    } 
                    // å‚ç›´è¿æ¥
                    else if (start.col === end.col) {
                        const top = Math.min(startRect.top, endRect.top) + startRect.height / 2;
                        const height = Math.abs(startRect.top - endRect.top);
                        
                        pathElement.style.left = `${startRect.left + startRect.width / 2 - 2}px`;
                        pathElement.style.top = `${top}px`;
                        pathElement.style.width = '4px';
                        pathElement.style.height = `${height}px`;
                    }
                    
                    document.body.appendChild(pathElement);
                }
            }
            
            // æ¸…é™¤è¿æ¥è·¯å¾„
            function clearPath() {
                const paths = document.querySelectorAll('.path');
                paths.forEach(path => path.remove());
            }
            
            // æ›´æ–°æ˜¾ç¤º
            function updateDisplay() {
                timeDisplay.textContent = state.timeLeft;
                scoreDisplay.textContent = state.score;
            }
            
            // æ›´æ–°è®¡æ—¶å™¨
            function updateTimer() {
                state.timeLeft--;
                updateDisplay();
                
                if (state.timeLeft <= 0) {
                    endGame();
                }
            }
            
            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
            function checkGameOver() {
                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æ–¹å—éƒ½å·²åŒ¹é…
                const allMatched = state.board.every(row => 
                    row.every(tile => tile.matched)
                );
                
                if (allMatched) {
                    // é¢å¤–å¥–åŠ±åˆ†æ•°
                    state.score += state.timeLeft * 2;
                    updateDisplay();
                    endGame();
                }
            }
            
            // ç»“æŸæ¸¸æˆ
            function endGame() {
                clearInterval(state.timer);
                state.isGameOver = true;
                
                // æ˜¾ç¤ºæ¸¸æˆç»“æŸæ¨¡æ€æ¡†
                finalScoreDisplay.textContent = state.score;
                gameOverModal.classList.add('show');
            }
            
            // æç¤ºåŠŸèƒ½
            function showHint() {
                // æŸ¥æ‰¾å¯ä»¥è¿æ¥çš„ä¸€å¯¹
                for (let row1 = 0; row1 < config.rows; row1++) {
                    for (let col1 = 0; col1 < config.cols; col1++) {
                        if (state.board[row1][col1].matched) continue;
                        
                        for (let row2 = 0; row2 < config.rows; row2++) {
                            for (let col2 = 0; col2 < config.cols; col2++) {
                                // è·³è¿‡å·²åŒ¹é…æˆ–ç›¸åŒçš„æ–¹å—
                                if (state.board[row2][col2].matched || 
                                    (row1 === row2 && col1 === col2)) continue;
                                
                                // æ£€æŸ¥æ˜¯å¦æ˜¯ç›¸åŒçš„emoji
                                if (state.board[row1][col1].emoji === state.board[row2][col2].emoji) {
                                    // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿æ¥
                                    const path = findPath(
                                        { row: row1, col: col1 },
                                        { row: row2, col: col2 }
                                    );
                                    
                                    if (path) {
                                        // é«˜äº®æ˜¾ç¤ºè¿™å¯¹æ–¹å—
                                        state.board[row1][col1].element.classList.add('selected');
                                        state.board[row2][col2].element.classList.add('selected');
                                        
                                        // 3ç§’åå–æ¶ˆé«˜äº®
                                        setTimeout(() => {
                                            state.board[row1][col1].element.classList.remove('selected');
                                            state.board[row2][col2].element.classList.remove('selected');
                                        }, 3000);
                                        
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }
                
                alert('æ²¡æœ‰å¯è¿æ¥çš„æ–¹å—å¯¹äº†ï¼');
            }
            
            // é‡æ’åŠŸèƒ½
            function shuffleBoard() {
                if (state.isGameOver) return;
                
                // æ”¶é›†æœªåŒ¹é…çš„æ–¹å—
                const unmatchedTiles = [];
                for (let row = 0; row < config.rows; row++) {
                    for (let col = 0; col < config.cols; col++) {
                        if (!state.board[row][col].matched) {
                            unmatchedTiles.push(state.board[row][col].emoji);
                        }
                    }
                }
                
                // æ‰“ä¹±é¡ºåº
                const shuffled = shuffleArray(unmatchedTiles);
                
                // é‡æ–°åˆ†é…
                let index = 0;
                for (let row = 0; row < config.rows; row++) {
                    for (let col = 0; col < config.cols; col++) {
                        if (!state.board[row][col].matched) {
                            state.board[row][col].emoji = shuffled[index++];
                            state.board[row][col].element.querySelector('.emoji-set').textContent = shuffled[index-1];
                        }
                    }
                }
                
                // å–æ¶ˆé€‰ä¸­çŠ¶æ€
                if (state.selectedTile) {
                    const { row, col } = state.selectedTile;
                    state.board[row][col].element.classList.remove('selected');
                    state.selectedTile = null;
                }
                
                // æ‰£åˆ†
                state.score = Math.max(0, state.score - 5);
                updateDisplay();
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæ‰“ä¹±æ•°ç»„
            function shuffleArray(array) {
                const newArray = [...array];
                for (let i = newArray.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
                }
                return newArray;
            }
            
            // äº‹ä»¶ç›‘å¬
            newGameBtn.addEventListener('click', initGame);
            hintBtn.addEventListener('click', showHint);
            shuffleBtn.addEventListener('click', shuffleBoard);
            playAgainBtn.addEventListener('click', initGame);
            
            // åˆå§‹åŒ–æ¸¸æˆ
            initGame();
        });
    </script>
</body>
</html>
